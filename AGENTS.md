# AGENTS.md

This file provides guidance to AI agents (Claude, Cursor, Copilot, etc.) when working with code in this repository.

## Philosophy

**This is an opinionated monorepo.** The packages here reflect personal preferences and workflows that have proven effective across multiple projects (both personal and professional).

The goal is NOT to create universally appealing tools that please everyone. Instead, this monorepo exists to:

- **Consolidate proven solutions**: Stop manually copying and syncing code between projects
- **Maintain consistency**: Use the same patterns and utilities across all work
- **Iterate faster**: Update once, benefit everywhere

If these opinions align with your needs — great! If not, these packages might not be the right fit, and that's perfectly fine.

This follows the same philosophy as `@shibanet0/datamitsu-config` (opinionated configs) built on top of `@datamitsu/datamitsu` (universal core).

**Note on contributions**: Since this reflects personal workflows, pull requests may be declined if they don't align with the project's direction. Forks are encouraged for different approaches.

## Project Overview

This monorepo contains the following packages:

- **@ovineko/react-router**: Type-safe wrapper for React Router v7 with valibot schema validation, automatic error handling, and typed params
- **@ovineko/spa-guard**: Production-ready chunk load error handling for SPAs — automatic retry with cache busting, `lazyWithRetry` for module-level retry before page reload, beacon error reporting, React error boundaries, debug test panel, Fastify plugin, and Vite plugin
- **@ovineko/clean-pkg-json**: Zero-config tool to clean package.json before publishing and restore it after
- **@ovineko/datamitsu-config**: Internal configuration package for datamitsu tooling (linting, formatting, etc.)
- **@ovineko/fastify-base**: Pre-configured Fastify server with Sentry, Prometheus, OpenTelemetry, healthcheck, and other common integrations

## Repository Structure

```plaintext
ovineko/
├── packages/                    # All publishable packages
│   ├── react-router/           # Type-safe React Router v7 wrapper (valibot validation)
│   ├── spa-guard/              # Chunk load error handling for SPAs (lazyWithRetry, beacons, debug panel, Vite plugin)
│   ├── clean-pkg-json/         # Package.json cleanup tool for publishing
│   ├── datamitsu-config/       # Shared config for datamitsu tooling
│   └── fastify-base/           # Pre-configured Fastify server with observability
├── test/                       # Shared test utilities and setup files
├── turbo.json                  # Turborepo build orchestration config
├── pnpm-workspace.yaml         # pnpm workspace configuration
├── datamitsu.ts                # Centralized linting/formatting config
├── .syncpackrc.json            # Dependency version sync rules
└── lefthook.yml                # Git hooks configuration
```

**Key directories per package:**

- `src/` - Source code (TypeScript)
- `dist/` - Build output (gitignored, generated by tsup)
- `test/` or colocated `*.test.ts` - Tests (vitest)
- `tsup.config.ts` - Bundler configuration
- `vitest.config.ts` - Test runner configuration
- `tsconfig.json` - TypeScript configuration (extends from datamitsu-config)

## Key Dependencies

### React Packages

- `react@19` - React library (peer dependency)
- `react-router@7` - Routing foundation for @ovineko/react-router
- `valibot` - Runtime validation library (used in react-router for params/search params)
- `@sentry/react` - Error tracking integration (optional peer dependency)

### Build & Bundling

- `tsup` - Fast TypeScript bundler with code splitting (uses esbuild)
- `typescript` - TypeScript compiler (for declaration files)
- `turbo` - Monorepo build orchestration from [Turborepo](https://turborepo.dev/)
- `pnpm` - Fast, disk space efficient package manager (workspace support)

### Testing Framework

- `vitest` - Fast unit test framework (Vite-powered)
- `@testing-library/react` - React component testing utilities
- `@testing-library/jest-dom` - Custom jest-dom matchers for assertions
- `happy-dom` - Lightweight DOM implementation for tests

### Code Quality

- `datamitsu` - Unified linting orchestrator that runs:
  - `oxlint` - Fast Rust-based linter (primary linter)
  - `eslint` - Additional JavaScript/TypeScript linting rules
  - `prettier` - Code formatter
  - `knip` - Detects unused exports and dependencies
  - `commitlint` - Validates conventional commit messages
  - `syncpack` - Syncs dependency versions across workspace
  - `gitleaks` - Scans for secrets in commits

### Git Hooks

- `lefthook` - Fast git hooks manager (runs pre-commit, commit-msg, post-checkout)

## Development Commands

### Installation

```bash
pnpm install
```

### Linting & Fixing

```bash
# Lint all packages
pnpm lint

# Auto-fix linting issues across all packages
pnpm fix

# Lint/fix in a specific package
cd packages/<package-name>
pnpm lint
pnpm fix
```

### Testing

```bash
# Run tests in a specific package
cd packages/<package-name>
pnpm test                # Run tests once
pnpm test:watch          # Run tests in watch mode
pnpm test:coverage       # Run tests with coverage report
pnpm test:ui             # Open Vitest UI
pnpm test:debug          # Run tests with console output visible (DEBUG=1)

# The test suite uses vitest with happy-dom environment
# Tests are located alongside source files (*.test.ts, *.test.tsx)
# Console output (log/warn/error) is suppressed by default; use test:debug to see it
```

### Building

```bash
# Build all packages (uses turbo for orchestration)
turbo build

# Build a specific package
cd packages/<package-name>
pnpm build              # For packages with 'build' script (react-router)
pnpm build:lib          # For packages with 'build:lib' script (clean-pkg-json)

# Build process:
# 1. tsup bundles the source code (ESM format)
# 2. TypeScript compiler generates .d.ts declaration files
# 3. Output goes to the 'dist' directory
```

### Publishing

```bash
# Publishing is handled automatically via prepack/postpack hooks
cd packages/<package-name>
pnpm publish

# The clean-pkg-json tool automatically cleans devDependencies before publishing
# and restores them after publishing
```

## Publishing Guidelines

### Version Management

- Each package has **independent versioning**
- Follow [semantic versioning](https://semver.org/) (semver):
  - **Major** (X.0.0): Breaking changes
  - **Minor** (0.X.0): New features (backward compatible)
  - **Patch** (0.0.X): Bug fixes (backward compatible)
- Keep CHANGELOG.md updated per package (optional but recommended)

### Pre-publish Checklist

Before publishing any package:

1. **Update version** in `package.json` following semver
2. **Run tests**: `pnpm test` (ensure 80%+ coverage)
3. **Run linter**: `pnpm lint` (must pass with no errors)
4. **Build package**: `pnpm build` (verify dist/ output)
5. **Check package contents**: `pnpm pack --dry-run` (preview what will be published)
6. **Update README.md** if API changed
7. **Update AGENTS.md** if patterns/workflows changed

### Dependency Version Rules

> **CRITICAL:** Follow syncpack rules for version ranges

- **Internal packages** (workspace): Always use `workspace:*`

- **Peer dependencies**: Always use caret (`^`) for compatibility range

  ```json
  {
    "peerDependencies": {
      "react": "^19.0.0",
      "react-router": "^7.0.0"
    }
  }
  ```

- **Regular dependencies**: No range prefix (exact pinning, empty string in syncpack)

  ```json
  {
    "dependencies": {
      "valibot": "1.0.0"
    }
  }
  ```

These rules are enforced by `.syncpackrc.json` and validated by `pnpm datamitsu lint`.

### Publishing Process

```bash
# 1. Navigate to package directory
cd packages/<package-name>

# 2. Verify everything is ready
pnpm test && pnpm lint && pnpm build

# 3. Publish to npm (requires npm authentication)
pnpm publish --access public

# The publish process automatically:
# - Runs prepack hook (cleans devDependencies via clean-pkg-json)
# - Publishes to npm registry
# - Runs postpack hook (restores package.json)
```

### Post-publish Tasks

After successful publishing:

1. **Tag release** (optional): `git tag @ovineko/<package>@<version>`
2. **Push tags**: `git push --tags`
3. **Update dependent packages** if API changed
4. **Announce release** (if significant changes)

## Architecture & Patterns

### Monorepo Structure

- **Root**: Contains shared configuration files (turbo.json, datamitsu.ts, eslint.config.js, etc.)
- **Packages**: Each package in `packages/` is independently versioned and publishable
- **Workspace protocol**: Internal dependencies use `workspace:*` for cross-package references

### Type Safety & Validation

The codebase emphasizes runtime type safety:

- **TypeBox** is the primary schema validation library used across most packages
- **Valibot** is specifically used in @ovineko/react-router for URL params and search params validation
- Type inference from schemas eliminates the need for duplicate TypeScript types

Example from @ovineko/react-router (using valibot):

```tsx
const route = createRouteWithParams("/users/:id", {
  params: v.object({ id: v.pipe(v.string(), v.uuid()) }),
  searchParams: v.object({
    page: v.optional(v.pipe(v.string(), v.transform(Number), v.number())),
  }),
  errorRedirect: "/404",
});
```

### React Patterns

- **React 19**: All React packages target React 19
- **Hooks-based architecture**: Prefer custom hooks for reusable logic
- **Memoization**: Use `useMemo`, `useCallback`, and `memo` for performance optimization when needed

### Testing Patterns

- **Vitest + Testing Library**: Component tests use @testing-library/react
- **happy-dom**: Lightweight DOM environment for tests
- **Co-located tests**: Test files live alongside source files (_.test.tsx, _.test.ts)
- **Setup files**: Vitest setup at `test/setup.ts` configures testing-library/jest-dom matchers and globally suppresses `console.log`, `console.warn`, and `console.error` during test runs (restored after each test). Set `DEBUG=1` (or run `pnpm test:debug`) to disable suppression when diagnosing failures.

### Testing Safety Rules

> **CRITICAL:** Tests must NEVER modify workspace root or shared state

- All tests MUST be isolated to their package scope
- Never run tests that modify workspace root `node_modules`
- Each package must be tested independently: `cd packages/<name> && pnpm test`
- Test coverage threshold: 80% (lines/branches/functions/statements)
- Use `vitest.workspace.ts` for multi-package test orchestration if needed
- Clean test artifacts in `afterEach`/`afterAll` hooks
- Mock external dependencies to prevent network calls or file system mutations
- Never commit `.only` or `skip` in test files

### Build Configuration

- **tsup**: Bundles source code with code splitting enabled
- **Entry pattern**: `src/**/*.tsx*` (excludes test files)
- **Output**: ESM format only (`"type": "module"`)
- **TypeScript**: Separate declaration generation after bundling

### Linting & Code Quality

The project uses **datamitsu** as a unified linting orchestrator that runs:

- **oxlint**: Fast Rust-based linter (primary linter)
- **ESLint**: Additional rules with oxlint plugin integration
- **Prettier**: Code formatting
- **knip**: Unused exports/dependencies detection
- **commitlint**: Conventional commit message validation
- **editorconfig-checker**: EditorConfig compliance
- **gitleaks**: Secret scanning
- **syncpack**: Dependency version synchronization

Configuration is centralized in `datamitsu.ts` with package-specific overrides.

### Git Workflow

Follow GitHub Flow with feature branches from main.

**Commit message format** (Conventional Commits):

- `feat:` new feature
- `fix:` bug fix
- `docs:` documentation
- `refactor:` code refactoring
- `test:` adding tests
- `chore:` maintenance

**Automated checks** (lefthook git hooks):

- **pre-commit**: Runs `datamitsu fix` and `datamitsu lint` on staged files only
- **commit-msg**: Validates commit messages with commitlint
- **post-checkout**: Automatically runs `pnpm install` when switching branches

## Important Requirements

- **Node.js**: >= 24.11.0
- **pnpm**: >= 10.25.0 (enforced by preinstall script)
- **Package Manager**: Only pnpm is allowed (enforced via only-allow)

## Package Dependencies

When adding dependencies:

- Use workspace references (`workspace:*`) for internal packages
- peer dependencies define required external packages (e.g., React 19, React Router 7)
- Use `pnpm add -D` for devDependencies, `pnpm add` for runtime dependencies
- Run `pnpm datamitsu fix` after adding dependencies to sync versions across packages

## Working with Individual Packages

Each package is self-contained with its own:

- `package.json` with scripts
- `tsconfig.json` extending from `@shibanet0/datamitsu-config`
- `.oxlintrc.json` and `eslint.config.js` (generated by datamitsu)
- `vitest.config.ts` (for packages with tests)
- `tsup.config.ts` (for packages with builds)

When modifying a package, always run its tests and ensure the build succeeds before committing.

## Package-Specific Notes

### @ovineko/react-router

- Requires React Router v7 as peer dependency
- URL params validated at runtime with valibot

### @ovineko/spa-guard

- Dual build system: tsup builds the library (`dist/`); a separate Terser pipeline builds the inline script (`dist-inline/` for production, `dist-inline-trace/` for trace/debug mode)
- Configuration flows from `spaGuardVitePlugin()` → injected as `window.__SPA_GUARD_OPTIONS__` at build time; all runtime code reads options exclusively from this global via `getOptions()`
- Two-level retry strategy: `lazyWithRetry` retries the individual module import first (`lazyRetry.retryDelays`), then falls back to full page reload via `attemptReload()` (`reloadDelays`)
- `src/common/retryImport.ts` is framework-agnostic retry logic; `src/react/lazyWithRetry.tsx` wraps it for `React.lazy` compatibility
- Event system uses `name` field as the discriminant (not `type`) in both internal `emitEvent()` calls and the public `events.subscribe()` API
- Peer dependency for `./react` export is `react@^19` only
- Test setup (`test/setup.ts`) globally suppresses `console.log/warn/error` to keep test output clean; run `pnpm test:debug` (sets `DEBUG=1`) to pass console output through when diagnosing test failures
- ESLint plugin name is dynamically computed as `${packageName}/eslint` (i.e., `@ovineko/spa-guard/eslint`) from `package.json` `name` field in `src/eslint/index.ts`; rule names follow as `@ovineko/spa-guard/eslint/no-direct-error-boundary` etc.
- ESLint v10 is supported (`^9 || ^10`); `@types/eslint` was removed because ESLint v10 ships its own types; the plugin uses `satisfies ESLint.Plugin` for type checking
- Injectable Logger via DI: all console output uses a `Logger` interface (`src/common/logger.ts`). `listenInternal(serializeError, logger?)` accepts an optional logger stored on `window[loggerWindowKey]` and retrieved via `getLogger()?.method()` (optional chaining for graceful degradation). `createLogger()` contains all human-readable message strings. The production inline entry (`src/inline/index.ts`) passes no logger so tree-shaking eliminates all log strings from the bundle. The trace entry (`src/inline-trace/index.ts`) passes `createLogger()` for full logging. `emitEvent()` auto-calls `getLogger()?.logEvent(event)` before notifying subscribers; the `EmitOptions.silent` flag suppresses this auto-logging (used by `shouldIgnoreMessages` filters)
- **Inline script rebuild requirement**: After any change to `src/common/` (core) code that could affect the inline scripts, you MUST rebuild inline scripts by running `pnpm build` from `packages/spa-guard/`. The build command (`tsup --config tsup.inline.config.ts && tsup --config tsup.inline.trace.config.ts`) outputs the minified file sizes for `dist-inline/index.js` (production) and `dist-inline-trace/index.js` (trace). After rebuilding, check the reported sizes and update the "Build Sizes" section in `packages/spa-guard/README.md` to match the new values (e.g., `~5.9 KB` → `~6.1 KB`).

### @ovineko/clean-pkg-json

- Automatically runs via npm lifecycle hooks
- No manual invocation needed

## Documentation Maintenance

**CRITICAL**: Keep documentation in sync with code changes.

Whenever you make changes to the codebase, **immediately update**:

1. **AGENTS.md** (this file)
   - Add to "Known Pitfalls" if you encountered issues
   - Update commands if scripts change
   - Add examples for new patterns introduced
   - Update architecture notes for significant refactoring

2. **README.md** (package-level)
   - Update usage examples when APIs change
   - Add new features to feature list
   - Update installation instructions if peer deps change
   - Refresh code examples to match current implementation

3. **package.json** metadata
   - `description`: Keep concise but accurate (< 120 chars)
   - `keywords`: Add relevant searchable terms (npm/GitHub discovery)
   - Update both when package functionality expands

### Documentation Update Triggers

Update docs when you:

- ✅ Add/remove/modify public APIs
- ✅ Change configuration patterns
- ✅ Fix a confusing bug (document the pitfall)
- ✅ Add new dependencies or peer dependencies
- ✅ Change build/test/lint workflows
- ✅ Introduce new architectural patterns

### Quick Documentation Check

Before finalizing any change:

```bash
# 1. Does AGENTS.md mention this pattern/pitfall?
# 2. Does package README show current usage?
# 3. Do package.json keywords reflect new functionality?
```

**Golden Rule**: If you had to figure something out, document it so others (and future AI agents) don't have to.

## Known Pitfalls

### Workspace protocol

- **Workspace protocol**: Never use specific versions for internal packages, always `workspace:*`

### Build output missing

Check that `tsup.config.ts` entry patterns exclude test files

<!-- Add corrections here as you encounter issues -->

## Verification

Before completing any task:

1. Run the test suite if tests exist
2. Run linter to check for issues
3. Verify changes work as expected

---

_Update this file whenever you make a mistake or discover a pitfall: "Update AGENTS.md so you don't make that mistake again"_
